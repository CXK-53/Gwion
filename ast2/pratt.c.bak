#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "token.h"
#define T_VAR 1

struct Parser {
  uint8_t* input;
  Token left;
  Token self;
};

static struct TokenDesc tokens[256];

static Token parse (struct Parser* p, int rbp);


static Token nud_add(struct Parser* p){
puts("add");
//  puts(p->left.value);
Token right = parse(p, 6);
  puts(right.value);
  return right;
//boole(0b0111, p->left, right);
}

static struct TokenDesc tokens[256] = {
/*
  ['?'] = { 1, NULL     , led_question },
  ['('] = { 0, nud_paren, NULL         },
  [')'] = { 0, NULL     , NULL         },
  ['>'] = { 2, NULL     , led_implies  },
  ['v'] = { 3, NULL     , led_or       },
  ['^'] = { 4, NULL     , led_and      },
  ['~'] = { 0, nud_not  , NULL         },
*/
  ['+'] = { 1, nud_add  , nud_add      },

};

static Token parse (struct Parser* p, int rbp);
static Token vars[256];

static Token generate(void) {
//  static int k = 1;

  Token t = {
    .type = T_VAR,
//    .value = calloc(k*2+1, 1),
.len = 0
  };

//  memset(t.value + 0, '0', k);
//  memset(t.value + k, '1', k);

//  k <<= 1;

  return t;
}

static Token nonud(struct Parser* p){
  if(tokens[p->self.type].led == NULL){
    Token t = vars[p->self.type];
//    if(t.value != '\0') {
    if(t.value) {
t.value[t.len++] = *p->input;
//exit(3);
p->self.value[p->self.len++] = *p->input;
printf("[%s] %s:%s %i %i\n", __func__, p->self.value, t.value, p->self.len, p->self.type);
//exit(3);
//p->self = 
return parse(p, 0);
return t;
//return p->self;
}
    else {
exit(3);
assert(p->self.type == T_VAR);
if(*p->input >= 'a' && *p->input <= 'Z') {
      p->self.value[t.len++] = *p->input;
printf("nonud (no value) %c %s\n", p->self.type, t.value);
//      vars[p->self.type] = t;
return parse(p, 0);
}
//      else
      vars[p->self.type] = t;
      return t;
    }
  } else {
    printf(" '%c' has no argument.\n", p->self.type);
    exit(1);
  }
}

static Token parse(struct Parser* p, int rbp){
printf("[%s] %c\n", __func__, *p->input);
  if(*p->input == 0)
    return (Token){};

  uint8_t c = *p->input++;
  p->self = (Token){ c };
//p->self.value[0] = c;

//  struct token_desc* d = tokens + c;
  struct TokenDesc* d = tokens + c;
  if(d->nud){
puts("has nud");
    p->left = d->nud(p);
  } else {
    p->left = nonud(p);
  }

  for(;;){
puts("start loop");
    c = *p->input;
    p->self = (Token){ c };
    d = tokens + c;

    if(c == 0)
      return (Token){};
puts("mark 0");
    if(rbp >= d->lbp) // orig
      break;

puts("mark 1");
    p->input++;

    if(d->led)
      p->left = d->led(p);
  }
puts("end of parse");
  return p->left;
}

int main(void){
  char buf[256];
  if(!fgets(buf, sizeof(buf), stdin))
    return 1;

  printf("Input: %s", buf);

  struct Parser p = {
    .input = (uint8_t*)buf,
  };

  parse(&p, 0);

  return 0;
}
