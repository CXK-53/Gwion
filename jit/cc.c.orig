#include <stdlib.h>
#include <string.h>
#include <jit/jit.h>
#include "defs.h"
#include "absyn.h"
#include "vm.h"
#include "operator.h"
#include "instr.h"
#include "shreduler_private.h"
#include "gwjit_common.h"
#include "cc.h"
#include "sig.h"
#include "code.h"
#include "ctrl.h"
#include "mpool.h"


typedef struct JitQ_* JitQ;
extern VM_Code qcode(JitQ);
extern struct ctrl* qctrl(JitQ);

struct Map_ ctrlmap, codemap;
struct Vector_ sfunvec, mfunvec;
#define XTOR(type, attr)      \
__attribute__((attr(400)))    \
void jitmap_##type() {        \
  map_##type(&codemap);       \
  map_##type(&ctrlmap);       \
  vector_##type(&sfunvec);    \
  vector_##type(&mfunvec);    \
}
XTOR(init,    constructor)
XTOR(release, destructor)

JitCC* new_cc(pthread_mutex_t* mutex) {
  JitCC* j = (JitCC*)xmalloc(sizeof(JitCC));
  j->ctx = jit_context_create();
  sig_ini(&j->sig);
  j->top = NULL;
  j->f = NULL;
  j->pool = new_pool(sizeof(struct Instr_), 128);
  j->mutex = mutex;
  return j;
}

ANN void free_cc(JitCC* j) {
  sig_end(&j->sig);
  if(j->top)
    _mp_free(j->pool, j->top);
  mp_end(j->pool);
  xfree(j->pool);
  jit_context_destroy(j->ctx);
  xfree(j);
}

ANN static void ini(const JitCC* j) {
  JitCC* cc = (JitCC*)j;
  jit_context_build_start(cc->ctx);
  cc->f = jit_function_create(cc->ctx, sig(&cc->sig, "vp"));
  cc->shred = jit_value_get_param(cc->f, 0);
}

INSTR(execute_jit) {
  void* arg[] = { (VM_Shred)&shred };
  jit_function_apply((jit_function_t)instr->m_val, arg, NULL);
}

ANN static void to_instr(const JitCC* j){
  const Instr base = (Instr)j->base;
  const Instr tmp = (Instr)j->top;
  base->execute = execute_jit;
  base->m_val = (m_uint)j->f;
//  base->m_val2 = (m_uint)j->pool;
  base->m_val2 = (m_uint)j;
  *(Instr*)base->ptr = tmp;
  ((JitCC*)j)->top = NULL;
}

ANN static void end(const JitCC* j) {
  JINSN0(default_return);
  jit_function_compile(j->f);
  jit_context_build_end(j->ctx);
  to_instr(j);
  ((JitCC*)j)->f = NULL;
}

ANN static void update_pc(const JitCC* j, struct ctrl* ctrl) {
  CJval pc = JCONST(nuint, ctrl_idx(ctrl) + 1);
  JSTORER(j->shred, JOFF(VM_Shred, pc), pc);
}

ANN static Instr get_instr(const JitCC* j, const Instr instr) {
  if(instr != j->base)
    return instr;
  const Instr ret = (Instr)_mp_alloc(j->pool);
  memcpy(ret, instr, sizeof(struct Instr_));
  ((JitCC*)j)->top = ret;
  return ret;
}

ANN void none(const JitCC* j, Instr byte) {
#ifdef JIT_DEV
fprintf(stderr, "[JIT] '%p' instr not found\n", (void*)(m_uint)byte->execute);
#endif
  CJval instr = JCONST(void_ptr, (jit_nint)byte);
  Jval  arg[] = { j->shred, instr };
  CALL_NATIVE((void*)(m_uint)byte->execute, "vpp", arg)
}

ANN static void handle_exception(const JitCC* j) {
  CJval vm   = JLOADR(j->shred, JOFF(VM_Shred, vm_ref), void_ptr);
  CJval tick = JLOADR(vm, JOFF(VM, shreduler), void_ptr);
  CJval curr = JLOADR(tick, JOFF(Shreduler, curr), void_ptr);
  CJval null = JCONST(void_ptr, 0);
  INIT_LABEL(lbl)
  CJval cond = JINSN2(eq, curr, null);
  JINSN2(branch_if_not, cond, &lbl);
  JINSN0(default_return);
  JINSN1(label, &lbl);
}

ANN static void refresh(const JitCC* j, const Instr byte) {
  if(j->f)
    end(j);
  ((JitCC*)j)->base = byte;
  ini(j);
}

ANN static inline void jit_prep(struct ctrl* ctrl, Vector v) {
  const m_uint size = vector_size(v);
  ctrl_refresh(ctrl, size);
}

#define CHECK_CODE(c, q) if(c->obj.ref_count == 1) { REM_REF(c); if(q)qunlock(q); return -1; }

typedef void (*_ctrl)(const Instr, const struct ctrl*);
ANN static m_bool jit_flow(const struct ctrl* c, JitQ q) {
  const VM_Code code = qcode(q);
  const Vector v = code->instr;
  const m_uint size = vector_size(v);
  for(m_uint i = ctrl_idx(c); i < size; ++i) {
    CHECK_CODE(code, NULL);
    ctrl_set(c, i);
    const Instr byte = (Instr)vector_at(v, i);
    const _ctrl ctrl = (_ctrl)map_get(&ctrlmap, (vtype)byte->execute);
qlock(q);
    if(ctrl)
      ctrl(byte, c);
qunlock(q);
  }
  return 1;
}

typedef void (*_code)(const JitCC*, Instr);
static m_bool jit_code(const JitCC* cc, JitQ q) {
  const VM_Code c = qcode(q);
  const struct ctrl* ctrl = qctrl(q);
  const Vector v = c->instr;
  const m_uint size = vector_size(v);
  ((JitCC*)cc)->f = qfunc(q);
//  ((JitCC*)cc)->base = (Instr)vector_front(v); // ?????
while(ctrl_run(ctrl)) {
    CHECK_CODE(c, q);
    const Instr byte = (Instr)vector_at(v, i);
    if(ctrl_get_pc(ctrl, i))
      refresh(cc, byte);
    ctrl_set(ctrl, i);
    update_pc(cc, ctrl);
    const Instr ins = get_instr(cc, byte);
    const _code code = (_code)map_get(&codemap, (vtype)byte->execute);
qlock(q);
//  jit_context_build_start(cc->ctx);
    if(code)
      code(cc, ins);
    else {
      none(cc, ins);
      if(ctrl_get_ex(ctrl, i))
        handle_exception(cc);
    }
//    update_pc(cc, ctrl);
//  jit_context_build_end(cc->ctx);
qunlock(q);
  }
  end(cc);
  return 1;
}

ANN void cc(const JitCC* cc, JitQ q) {
  const VM_Code code = qcode(q);
  const struct ctrl* ctrl = qctrl(q);
  if(!ctrl_state(ctrl)) {
    if(jit_flow(ctrl, q) < 0)
      return;
    ctrl_done(ctrl);
  }
  if(jit_code(cc, q) < 0)
    return;
  REM_REF(code);
}
