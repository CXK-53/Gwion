#require Std
#require Math
#require Modules

enum Pitch { C, D, E, F, G, A, B }

class MusicObject {
  fun UGen update() {}
  fun UGen onStart() {}
  fun UGen onEnd() {}
}

var SinOsc osc;

class MyTone extends MusicObject {
  var float freq;

  fun UGen onStart() {
    freq => osc.freq;
    return osc => dac;
  }

  fun UGen onEnd() {
    return osc =< dac;
  }
}

fun MyTone tone(float freq) {
  var MyTone t;
  660 => t.freq;
  return t;
}

class Note extends MusicObject {
  var Pitch pitch;
  var int accidental;
  var int octave;

  
  fun int toMidi() {
    var int p;

    match (pitch) {
      case C: 0 => p;
      case D: 2 => p; 
      case E: 4 => p;
      case F: 5 => p;
      case G: 7 => p;
      case A: 9 => p;
      case B: 11 => p;
    }

    return p + (12 * (octave+1)) + accidental;
  }

  fun UGen onStart() {
    toMidi() => Std.mtof => osc.freq;
    return osc => dac;
  }

  fun UGen onEnd() {
    osc =< dac;
  }
}

fun Note note(Pitch pitch, int accidental, int octave) {
  var Note n;
  A => n.pitch;
  0 => n.accidental;
  4 => n.octave;
  return n;
}

class Coord {
  var dur start;
  var dur end;
}

fun Coord coord(dur start, dur end) {
  const Coord c;
  start => c.start;
  end => c.end;
  return c;
}

class TLEvent {
  fun dur getStart() {}
  fun void doIt() {}
}

class StartTLEvent extends TLEvent {
  var dur start;
  var MusicObject obj;
  fun dur getStart() { return start; }
  fun void doIt() {
    obj.onStart();
  }
}

fun StartTLEvent startevent(dur start, MusicObject obj) {
  const StartTLEvent evt;
  start => evt.start;
  obj @=> evt.obj;
  return evt;
}

class EndTLEvent extends TLEvent {
  var dur start;
  var MusicObject obj;
  fun dur getStart() { return start; }
  fun void doIt() {
    obj.onEnd();
  }
}

fun EndTLEvent endevent(dur start, MusicObject obj) {
  const EndTLEvent evt;
  start => evt.start;
  obj @=> evt.obj;
  return evt;
}

class DTimeline {
  var TLEvent events[0];

  fun void add(TLEvent event) {
    for (0 => var int i; i < events.size(); ++i) {
      if (event.getStart() < events[i].getStart()) {
        for (events.size()-1 => var int j; j >= i; --j) {
          events[j-1] @=> const TLEvent temp;
          events[j] @=> events[j-1];
          temp @=> events[j];
        }
        return;
      }
    }
    events << event;
  }

  fun void perform() {
    0::second => var dur current;
    foreach(evt:events) {
      evt.getStart() - current => now;
      evt.getStart() => current;
      evt.doIt();
    }
  }
}

class Frame {
  var int test;
  var Coord coord;
  var MusicObject objs[0];
}

class Timeline {
  const Frame frames[0];

  fun void add(Coord c, MusicObject obj) {
    var Frame toAdd;
    for (0 => var int i; i < frames.size(); ++i) {
      if ((c.start >= frames[i].coord.start) && (c.start <= frames[i].coord.start) 
           && (c.end >= frames[i].coord.end) && (c.end <= frames[i].coord.end)) {
        frames[i].objs << obj;
        return;
      }
    }
    var Coord c2;
    c.start => c2.start;
    c.end => c2.end;
    toAdd.objs << obj;
    c2 @=> toAdd.coord;
    frames << toAdd;
  }

  fun DTimeline toDTimeline() {
    var DTimeline theTL;
    foreach(frame:frames) {
      foreach(obj:frame.objs) {
        theTL.add(startevent(frame.coord.start, obj));
        theTL.add(endevent(frame.coord.end, obj));
      }
    }
    return theTL;
  }

  fun void perform() {
    this.toDTimeline().perform();
  }
}

var Timeline t;
t.add(coord(0::second, 2::second), note(A,0,4));
t.add(coord(2::second,4::second), note(C,1,5));
<<< t.frames[0].objs.size() >>>;
t.perform();
